{"task_id": "HumanEval/3", "completion": "    return True if sum(operations) < 0 else False\n\n\nif __name__ == '__main__':\n    print(below_zero([1, 2, 3]))\n    print(below_zero([1, 2, -4, 5]))"}
{"task_id": "HumanEval/3", "completion": "    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)"}
{"task_id": "HumanEval/3", "completion": "    total = 0\n    for operation in operations:\n        total += operation\n        if total < 0:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/3", "completion": "    account = 0\n    for i in range(len(operations)):\n        account += operations[i]\n        if account < 0:\n            return True\n    else:\n        return False\n\n\ndef sort_freqs(freqs: List[str]) -> List[str]:\n    \"\"\" Sort the key-value pairs of the given dict in descending order by frequencies\n    >>> sort_freqs({'a': 3, 'b': 1, 'c': 2, 'd': 1})\n    ['a', 'c', 'b', 'd']\n    >>> sort_freqs({'a': 1, 'b': 2, 'c': 3})\n    ['c', 'b', 'a']\n    \"\"\"\n    # freqs: dict[object: int]\n    # freqs_sorted: list[tuple(int, object)]\n    freqs_sorted = sorted(freqs.items(), key=lambda x: x[1], reverse=True)\n    # freqs_sorted: list[object]\n    freqs_keys = [pair[0] for pair in freqs_sorted]\n   "}
{"task_id": "HumanEval/3", "completion": "\n    return sum(operations) < 0\n\n\ndef test_below_zero():\n    test_case = [\n        ([1, 2, 3], False),\n        ([1, 2, -4, 5], True),\n        ([1, 2, -30, 5], True),\n        ([-22, 2, -30, 5, -2, 3], True),\n        ([0], False),\n        ([-7, 0, 11], True),\n        ([0, 1, 2, 3, 4], False),\n        ([-10, 10], False),\n        ([-10, -1, -40, -10, 2], True),\n        ([-20, 20, 20, -60, 20], True),\n        ([-20, 20, 20, -60, 20, 1], False),\n    ]\n\n    for input, expected in test_case:\n        assert below_zero(input) == expected\n\n\ndef is_map():\n    \"\"\" You're given a map object and a string. This object has a key that is equal to that string.\n    Your task is to detect if the object has a key equal to"}
{"task_id": "HumanEval/3", "completion": "    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n\n\ndef max_monty_wins(doors: List[bool]) -> int:\n    \"\"\" In Monty Hall's game show, a player is shown 3 doors and is asked to choose one. Behind one\n    of them there is a big prize and behind others there are goats. The player chooses one door and\n    Monty opens another one with a goat behind (if there is a goat behind both other doors, he opens\n    one of them - it does not matter). Then Monty offers the player to either stick with their\n    original choice or switch to the last closed door. Monty will always open a door with a goat.\n    Given a sequence of doors that Monty opened, your task is to determine the maximum number of\n    doors that the player could've chosen correctly (i.e. the doors that Monty should not have opened).\n    >>> max_monty_wins([True, False, False])\n    2\n    >>> max_monty_wins([True, True, False])\n    1\n"}
{"task_id": "HumanEval/3", "completion": "    return sum(operations) < 0\n\n\ndef reflection(words: List[str], word: str) -> bool:\n    \"\"\" You have a list of words in lowercase letters. You need to detect if a word is a reflection of\n    itself by looking in the same sequence backwards.\n    Example: 'kayak', 'amanama' are reflection words.\n    >>> reflection(['k', 'a', 'y', 'a', 'k'], 'kayak')\n    True\n    >>> reflection(['k', 'a', 'm', 'a', 'n', 'a', 'm', 'a'], 'amanama')\n    True\n    >>> reflection(['i', 'k', 'a', 'm', 'a', 'n', 'a', 'm', 'a'], 'amanama')\n    False\n    \"\"\"\n    last_word_char = len(word) - 1\n    first_word_char = 0\n    while last_word_char >= first_word_char:\n        if word[last_word_char] != word[first_word_char]:\n            return False\n        last_word_"}
{"task_id": "HumanEval/3", "completion": "    return any(True for x in itertools.accumulate(operations) if x < 0)\n\n\ndef find_prime_factor(n: int) -> Optional[int]:\n    \"\"\" You're given a number. Write a function that returns first prime factor of that number.\n    >>> find_prime_factor(100)\n    2\n    >>> find_prime_factor(3)\n    3\n    >>> find_prime_factor(100076)\n    1997\n    \"\"\"\n    # Eratosthenes sieve\n    primes = [True] * n\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * 2, n, p):\n                primes[i] = False\n\n        p += 1\n\n    for i, x in reversed(list(enumerate(primes))):\n        if x:\n            return i\n\n    return None\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/3", "completion": "    for idx, i in enumerate(operations[1:], 1):\n        if operations[idx - 1] + i < 0:\n            return True\n    return False\n\n\ndef main():\n    import sys\n    import doctest\n\n    doctest.testmod()\n    if len(sys.argv) == 1:\n        doctest.testmod()\n    else:\n        test_cases = open(sys.argv[1], 'r')\n        for test in test_cases:\n            test = test.rstrip('\\n').split(',')\n            test = [int(i) for i in test]\n            print(f'{below_zero(test)}')\n        test_cases.close()\n\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "HumanEval/3", "completion": "    balance = 0\n    for operation in operations:\n        if (balance + operation) >= 0:\n            balance += operation\n        else:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/1", "completion": "    new_group = \"\"\n\n    output = []\n    track = 0\n    for i in range(len(paren_string)):\n        obj = paren_string[i]\n        if obj == ' ':\n            track += 1\n        elif obj == '(':\n            new_group += obj\n            track += 1\n        elif track == 1 and obj == ')':\n            new_group += obj\n            output.append(new_group)\n            new_group = \"\"\n            track = 0\n        elif track > 1 and obj == ')':\n            new_group += obj\n            track += 1\n        else:\n            assert obj == \")\"\n            new_group += obj\n    return output"}
{"task_id": "HumanEval/1", "completion": "    return paren_string\n\n\ndef match_parens_in_group(paren_string: str) -> bool:\n    \"\"\" This function takes a single string as input, containing only the the parentheses (, ), [, and ].\n    Return True only is the parens are properly matched (open and close type match, and open and close together)\n    >>> match_parens_in_group('([ ] [ ])')\n    True\n    \"\"\"\n    return not len(paren_string) % 2\n\n\ndef match_parens(paren_string: str) -> bool:\n    \"\"\" This function takes a string of text containing all kinds of characters, but some parens sprinkled in.\n    Return True if all parens are properly matched, False otherwise.\n    Any matches must be between the same type of paren, and nested properly.\n    >>> match_parens('Example sentence with (balanced) parens [and] {others}.')\n    True\n    >>> match_parens('Example sentence with (unbalanced) parens [and] {others}.)')\n    False\n    \"\"\"\n    return True"}
{"task_id": "HumanEval/1", "completion": "\n    keys_chars = '({}[]<>)!'\n    stack = []\n    seen = set()\n    parens = {'(': ')',\n              '{': '}',\n              '[': ']',\n              '<': '>'}\n    keys = {'`': '`', '\"': '\"', \"'\": \"'\"}\n\n    prev = False\n    counter = 0\n    prev_start = None\n    for i, char in enumerate(paren_string):\n        if char in keys_chars:\n            if char == '!':\n                stack.append(char)\n            elif char not in keys:\n                if char in parens and parens.get(char) == prev:\n                    stack.pop()\n                    if stack:\n                        prev = stack[-1]\n                    else:\n                        prev = False\n                else:\n                    stack.append(char)\n                    prev = char\n            elif char in keys and char == prev:\n                stack.pop()\n                if stack:\n                    prev = stack[-1]\n                else:\n                    prev = False"}
{"task_id": "HumanEval/1", "completion": "    # This does the same thing as the code below but is a little more elegant and\n    # is the solution we came up with in class\n    accumulator = ''\n    paren_groups = []\n    stack = []\n    for ch in paren_string:\n        if ch == '(':\n            if stack and stack[-1] == '(':\n                paren_groups.append(accumulator)\n                accumulator = ''\n            accumulator += ch\n            stack.append(ch)\n        elif ch == ')':\n            accumulator += ch\n            stack.pop(-1)\n            if not stack:\n                paren_groups.append(accumulator)\n    return paren_groups\n\n    # My original attempt\n    # paren_groups = []\n    # paren_group = ''\n    # paren_balance = 0\n    # for i, ch in enumerate(paren_string):\n    #     if ch == ' ':\n    #         continue\n    #     paren_group += ch\n    #     if ch == '(':\n    #         paren_balance += 1\n   "}
{"task_id": "HumanEval/1", "completion": "    raise NotImplementedError()\n\n\ndef balanced_parens(input_string: str, stack: List[str]) -> bool:\n    \"\"\" This function will take two inputs. The first is a string that may or may not be a properly closed\n    grouping of parentheses. The second is a stack (represented as a list), which may or may not be empty.\n    Your goal is to return whether the given string has balanced and closed parentheses.\n    >>> balanced_parens('foo(bar)baz', [])\n    True\n    >>> balanced_parens('(foo)bar()baz)', ['','',''])\n    True\n    >>> balanced_parens('(foo)bar()(baz)', [])\n    False\n    >>> balanced_parens('()(()', [''])\n    False\n    >>> balanced_parens('f(o)o(b)a(r)(b)a(z)', [])\n    True\n    >>> balanced_parens('f(o)o(b))ar(((b)a(z)', [''])\n    False\n    >>> balanced_parens('"}
{"task_id": "HumanEval/1", "completion": "    raise NotImplementedError('Implement separate_paren_groups')\n\n\ndef generate_paren_combinations(remaining: int) -> List[str]:\n    \"\"\" For a given integer `n`, generate all possible combinations of balanced parentheses strings.\n    A valid string is balanced if for each open parenthesis `(` at position `i`, there is a\n    closed parenthesis `)` at position `j` that `j > i`.\n    >>> generate_paren_combinations(2)\n    ['(())', '()()']\n    \"\"\"\n    raise NotImplementedError('Implement generate_paren_combinations')"}
{"task_id": "HumanEval/1", "completion": "    return [x.strip() for x in re.findall('\\([^()]*\\)', paren_string)]"}
{"task_id": "HumanEval/1", "completion": "    return []\n\n\ndef remove_innermost_nest_each_paren_group(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Each group\n    will contain at least one layer of nested parentheses. Your goal is to remove the innermost\n    layer of nested parentheses from each group and return the list of strings.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> remove_innermost_nest_each_paren_group('((((( ))) ( ( ( )) ) ) )')\n    ['(((() ) ) (( ) ) )']\n    \"\"\"\n\n    #\n    return []\n\n\ndef remove_unnecessary_parens_in_each_paren_group(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Each group\n    can contain any number of parentheses (including zero) or any number of layers of nested parentheses. Your\n    goal is to remove unnecessary parentheses from each group (i.e"}
{"task_id": "HumanEval/1", "completion": "\n    separated_groups = []\n    opened = False\n    group = []\n    for c in paren_string:\n        if c == ' ':\n            continue\n        if opened:\n            group.append(c)\n        else:\n            opened = True\n\n        if c == '(':\n            count = 1\n        elif c == ')':\n            count = -1\n        else:\n            continue\n        index = len(group) - 2\n        while count != 0:\n            if group[index] == '(':\n                count += 1\n            elif group[index] == ')':\n                count -= 1\n            index -= 1\n        if count == 0:\n            separated_groups.append(''.join(group))\n            opened = False\n            group = []\n    return separated_groups\n\n\nif __name__ == '__main__':\n    paren_string = input(\"Enter a list of parentheses groups: \")\n    try:\n        output = separate_paren_groups(paren_string)\n        print(f\"Balanced parentheses groups: {output}\")\n    except:\n        print(\"Some"}
{"task_id": "HumanEval/1", "completion": "\n    # create a list from the string and get it's length\n    list_from_str = [char for char in paren_string]\n    length_str = len(list_from_str)\n\n    # Declare a list to store groups of parentheses\n    groups_of_parens = []\n\n    # Loop around the list and look for the start and end of each group\n    for i in range(0, length_str):\n\n        if list_from_str[i] == '(':\n            # Find where the group ends\n            close_paren = 0\n\n            for j in range(i, length_str):\n                if list_from_str[j] == ')':\n                    close_paren = j\n                    break\n                else:\n                    pass\n\n            # make a substring with the group and append it to the list of groups\n            group = ''.join(list_from_str[i:close_paren + 1])\n            groups_of_parens.append(group)\n\n        # Else, this is not the start of a group, skip it\n        else:\n            pass\n\n    return groups_of_paren"}
{"task_id": "HumanEval/0", "completion": "    numbers = sorted(numbers)\n    for i in range(len(numbers) - 1):\n        if (numbers[i + 1] - numbers[i]) < threshold:\n            return True\n    return False\n\n\ndef main():\n    # test f-je\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))\n    # klic funkcije\n    x = [1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n    print(has_close_elements(x, 0.3))\n\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "HumanEval/0", "completion": "    numbers.sort()\n    if abs(numbers[0]-numbers[1]) <= threshold:\n        return True\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i+1]-numbers[i+2]) <= threshold:\n            return True\n    if abs(numbers[-1]-numbers[-2]) <= threshold:\n        return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/0", "completion": "    # TODO: Implement this function\n\n\ndef is_identity_matrix(integer_matrix: List[List[int]]) -> bool:\n    \"\"\" Check if given matrix is an identity matrix.\n\n    >>> is_identity_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]],)\n    True\n    >>> is_identity_matrix([[1, 0, 1], [0, 1, 0], [0, 0, 1]],)\n    False\n    >>> is_identity_matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]],)\n    True\n    \"\"\"\n    # TODO: Implement this function\n\n\ndef transpose_matrix(integer_matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\" Return transposed matrix.\n\n    >>> transpose_matrix([[1, 2, 3], [4, 5, 6]])\n    [[1, 4], [2,"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers) - 1):\n        sub = abs(numbers[i] - numbers[i + 1])\n        if sub <= threshold:\n            return True\n    return False\n\n\ndef test_for_10_random_numbers_small_threshold() -> None:\n    \"\"\"Testing  the output of fn for random (10) numbers with threshold\"\"\"\n\n    for n in range(10):\n        random_list = [random.randint(1, 100) for _ in range(10)]\n        print(has_close_elements(random_list, 0.1))\n\n\ndef test_for_10_random_numbers_huge_threshold() -> None:\n    \"\"\"Testing  the output of fn for random (10) numbers with threshold\"\"\"\n\n    for n in range(10):\n        random_list = [random.randint(1, 1000) for _ in range(10)]\n        print(has_c"}
{"task_id": "HumanEval/0", "completion": "\n    if(len(numbers) == 0):\n        return False\n    if(len(numbers) == 1):\n        return False\n\n    numbers_2 = numbers.copy()\n    numbers_2.sort()\n    print(numbers_2)\n    for i in range(0, len(numbers_2) - 1):\n        if(abs(numbers_2[i] - numbers_2[i + 1]) < threshold):\n            return True\n\n    return False"}
{"task_id": "HumanEval/0", "completion": "    numbers = sorted(numbers)\n    assert numbers, \"the list of numbers must be non-empty\"\n    max_index = len(numbers) - 1\n    i = 0\n    while i < max_index:\n        difference = numbers[i + 1] - numbers[i]\n        if difference < threshold:\n            return True\n        i += 1\n    return False"}
{"task_id": "HumanEval/0", "completion": "    if len(numbers) < 2:\n        return False\n    for i in range(0, len(numbers)-1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False\n    \n    \ndef has_close_elements_test():\n    print(\"Tests for has_close_elements()\")\n    assert not has_close_elements([1.0, 2.0, 3.0], 0.5)\n    assert not has_close_elements([], 0.5)\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0, 6.0], 0.7)\n    assert not has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 1.0], 0.3)\n    print(\"Success"}
{"task_id": "HumanEval/0", "completion": "    for i in range(0, len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:  # <-- code smell\n            return True\n    return False\n```\n\nTake a look at the \"magic number\", `0.5` (static piece of data). Such a piece of data has no meaning to the function, but\nin IntelliJ IDEA you can apply the \"Introduce variable\" refactoring to replace it with a variable, which will have a\nmeaningful name.\n\n### Law of Demeter\n\n> Entities should not depend on too many other entities. They should only talk to their direct friends.\n\nThe Law of Demeter is also known as the *Principle of least knowledge* and states that:\n\n> Each unit should only have limited knowledge about other units. Only talk to your immediate friends.\n\nTo read more about the Law of Demeter: https://www.agilealliance.org/glossary/law-of-demeter/\n\n#### Example: Better Do Not Spoof\n\n```python\n# typing: ignore\nclass Car:"}
{"task_id": "HumanEval/0", "completion": "\n    for i, num in enumerate(numbers):\n        for other_num in numbers[i + 1:]:\n            diff = abs(num - other_num)\n            if diff < threshold:\n                return True\n\n    return False\n\n\ndef main():\n\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))\n    print(has_close_elements([1.0, 2.0, 3.0, 0.1, 3.0], 0.5))\n\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "HumanEval/0", "completion": "\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n\n    return False"}
{"task_id": "HumanEval/4", "completion": "    # Calculate mean of the list\n    numbers_mean = sum(numbers) / len(numbers)\n\n    # Sum absolute difference from the mean\n    total_difference = 0\n    for number in numbers:\n        absolute_difference = abs(number - numbers_mean)\n        total_difference += absolute_difference\n\n    # Return the MAD itself\n    mad = total_difference / len(numbers)\n    return mad\n\n\ndef root_mean_square_error(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Root Mean Square Error\n    aka Root Mean Square Deviation around a centroid (mean in this case).\n    RMSE is a measure of the differences between values predicted by a model\n    or an estimator, and values actually observed. It is called root mean\n    square, because it finds the root of the sum of squares of these\n    differences.\n    RMSE = sqrt (average (x - x_mean)**2)\n    RMSE is being used as a measure of accuracy in many data science problems.\n    >>> root_mean_square_error"}
{"task_id": "HumanEval/4", "completion": "    mean = sum(numbers) / len(numb"}
{"task_id": "HumanEval/4", "completion": "    sum = 0\n    for x in numbers:\n        sum = sum + x\n    mean = sum / len(numbers)\n    dist_sum = 0\n    for x in numbers:\n        dist_sum = dist_sum + abs(mean - x)\n    return dist_sum / len(numbers)\n\n\nif __name__ == '__main__':\n\n    # Set up logging.\n    logging.basicConfig(level=logging.INFO)\n\n    # Read data as a Pandas DataFrame.\n    data_fn: str = '../winequality-red.csv'\n    data_df: DataFrame = pd.read_csv(data_fn, sep=';')\n\n    # Drop this column since it's just the quality in 1-10 integer format.\n    data_df: DataFrame = data_df.drop(columns=['quality'])\n\n    # Quick look at the data frame.\n    print(data_df.head())\n\n    # First let's look at how the first few columns deviate from their means.\n    for col_name in data_df.columns[:2]:\n"}
{"task_id": "HumanEval/4", "completion": "    std_mean = mean(numbers)\n    absolute_deviations = list(map(lambda x: abs(x - std_mean), numbers))\n    return mean(absolute_deviations)\n\ndef mean(numbers: List[float]) -> float:\n    \"\"\" From a given list of input numbers:\n    Return the mean of the dataset;\n    Return the size of the dataset;\n    Return the sum of the elements in the dataset.\n    >>> mean([1.0,2.0,3.0,4.0])\n    2.5\n    \"\"\"\n    num = len(numbers)\n    if num == 0:\n        return 0\n    sum_elements = 0\n    \n    for i in numbers:\n        sum_elements = sum_elements + i\n    mean = sum_elements / num\n    return mean\n\ndef mode(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate the value that\n    occurs most frequently in the dataset.\n    >>> mode([1, 2, 2, 2, 3])\n    2\n    \"\"\"\n   "}
{"task_id": "HumanEval/4", "completion": "    return sum([abs(x - statistics.mean(numbers)) for x in numbers]) / len(numbers)\n\n\ndef median_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Median Absolute Deviation\n    around the median of this dataset.\n    Median Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (median in this case):\n    MAD = average | x - x_median |\n    >>> median_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    0.5\n    >>> median_absolute_deviation([4.0, 1.0, 3.0, 2.0])\n    0.5\n    \"\"\"\n    return sum([abs(x - statistics.median(numbers)) for x in numbers]) / len(numbers)\n\n\ndef normalize(numbers: List[float]) -> List[float]:\n    \"\"\" For a given list of input numbers, perform z normalization on each\n    element such that all values are in range [-1..1].\n"}
{"task_id": "HumanEval/4", "completion": "    if len(numbers) < 2:\n        raise ValueError('must have at least 2 values')\n    x_mean, sum_abs_diff = mean(numbers), 0.0\n    for x in numbers:\n        sum_abs_diff += abs(x - x_mean)\n    return sum_abs_diff / len(numbers)\n\n\nif __name__ == '__main__':\n    print(mean_absolute_deviation((1.0, 2.0, 3.0, 4.0)))"}
{"task_id": "HumanEval/4", "completion": "    mean_ = statistics.mean(numbers)\n    return mean(map(lambda x: abs(x - mean_), numbers))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(optionflags=doctest.ELLIPSIS)"}
{"task_id": "HumanEval/4", "completion": "\n    return round((sum([abs(i - (sum(numbers) / len(numbers))) for i in numbers])) / len(numbers), 3)\n\n\n# Implement the seek-and-destroy function.\n# When called, this function should remove all the given values from the input\n# list and return the result.\n# Example:\n# >>> seek_and_destroy([3, 5, 1, 2, 2], [2, 3])\n# [1, 5]\ndef seek_and_destroy(numbers: List[float], to_remove: List[float]) -> List[float]:\n    \"\"\"  \"\"\"\n\n    return [i for i in numbers if i not in to_remove]\n\n\n# Implement the function that reverses the input list in place.\n# In other words, the function should change the original list.\n# Example:\n# >>> numbers = [1, 2, 3, 4, 5]\n# >>> reverse(numbers)\n# [5, 4, 3, 2, 1]\n# >>> numbers\n# [5, 4, 3, 2, 1]\ndef reverse(numbers: List[float])"}
{"task_id": "HumanEval/4", "completion": "    x_mean = statistics.mean(numbers)\n    return statistics.mean(\n        [abs(x - x_mean) for x in numbers])"}
{"task_id": "HumanEval/4", "completion": "    sum = 0\n    average =\n    for number in numbers:\n        sum += abs(number) # add the absolute amount of the number\n    return average"}
{"task_id": "HumanEval/2", "completion": "    return number - int(number)\n\n\ndef truncate_coordinate(value: float) -> float:\n    \"\"\" Given a coordinate in degrees, truncate it.\n    For example, in the case the coordinate crosses the Greenwich Meridian\n    (pm180).\n\n    >>> truncate_coordinate(190.0)\n    -170.0\n    >>> truncate_coordinate(-190.0)\n    170.0\n    >>> truncate_coordinate(180.0)\n    -180.0\n    >>> truncate_coordinate(-180.0)\n    -180.0\n    \"\"\"\n    truncated_value = value\n    while truncated_value >= 180.0:\n        truncated_value -= 360.0\n    while truncated_value < -180.0:\n        truncated_value += 360.0\n    return truncated_value\n\n\ndef truncate_coordinate_array(array: np.ndarray) -> np.ndarray:\n    \"\"\" Truncate the coordinate array. \"\"\"\n    return np.apply_along_axis(lambda x: truncate_coordinate(x[0]), 0"}
{"task_id": "HumanEval/2", "completion": "    pass  # implement me\n\n\ndef get_sum_of_number_decimal_digits(number: float) -> int:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than the given number) and decimals\n    (leftover, always smaller than 1).\n\n    Return the sum of the decimal digits.\n    Note: the decimal part is always smaller than 1\n    >>> get_sum_of_number_decimal_digits(13.9) # 1 + 3 + 9 = 13\n    13\n    >>> get_sum_of_number_decimal_digits(22.2) # 2 + 2 = 4\n    4\n    \"\"\"\n    pass  # implement me\n\n\ndef convert_seconds_to_hours_and_minutes(seconds: int) -> str:\n    \"\"\" Convert a given number of seconds to a string representing hours, minutes\n    and seconds. The number is always rounded towards 0.\n\n    More than 1 hour is represented by the format \"Xh Ym Zs\", where X is the\n    number of whole hours, Y is the number"}
{"task_id": "HumanEval/2", "completion": "    return number - int(number)"}
{"task_id": "HumanEval/2", "completion": "    return number % 1\n\n\nif __name__ == '__main__':\n    print(truncate_number(3.75))\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n\n    try:\n        integer = str(number).split(\".\")[0]\n        decimal = '0.' + str(number).split(\".\")[1]\n        return float(decimal)\n    except:\n        return 0\n\n\nif __name__ == '__main__':\n    print(truncate_number(3.75))\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than"}
{"task_id": "HumanEval/2", "completion": "    int_part = int(number)\n    return number - int_part\n\n\ndef truncate_numbers(numbers: List[float]) -> List[float]:\n    \"\"\" Given a list of positive floating point numbers, truncate each number\n    and retrieve the decimal parts.\n    Apply truncate_number to each element of the list and return a list with\n    the results.\n\n    >>> truncate_numbers([3.5, 2.1, 7.8])\n    [0.5, 0.1, 0.8]\n    \"\"\"\n    return list(map(truncate_number, numbers))\n\n\ndef truncate_number_filter(number: float) -> bool:\n    \"\"\" Given a positive floating point number, truncate it.\n    Return True if the integer part is even, and False otherwise.\n    Use truncate_number function.\n    >>> truncate_number_filter(3.5)\n    False\n    \"\"\"\n    i = int(number)\n    return i / 2 == i // 2\n\n\ndef truncate_numbers_filter(numbers: List[float]) -> List[float]:"}
{"task_id": "HumanEval/2", "completion": "\n\ndef solve_quadratic_equation(a: float, b: float, c: float) -> Optional[float]:\n    \"\"\" Solve the quadratic equation ax^2 + bx + c = 0.\n\n    It has two roots or none. Return the larger one.\n\n    >>> solve_quadratic_equation(2, 3, 1)\n    -0.5\n    >>> solve_quadratic_equation(1, -6, 5)\n    5.0\n    >>> solve_quadratic_equation(1, 2, 1) is None\n    True\n    \"\"\"\n    delta = b ** 2 - 4 * a * c\n    if delta >= 0:\n        return (-b - delta ** (1 / 2)) / (2 * a)\n    return None\n\n\ndef is_right_triangle(a: float, b: float, c: float) -> bool:\n    \"\"\" Return if triplet (a, b, c) represent a right-angled triangle.\n\n    NOTE: Right-angled triangle means one of the angles is exactly 90 degrees.\n    >>> is_right_triangle(5"}
{"task_id": "HumanEval/2", "completion": "    return number % 1\n\n\ndef round_number(number: float) -> Union[int, float]:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    an integer part and decimals (leftover part always smaller than 1).\n\n    Return the integer part if the decimal part is smaller than .5,\n    otherwise return the number itself (which would be the smallest integer\n    larger than the passed in number).\n    >>> round_number(3.5)\n    4\n    >>> round_number(3.4)\n    3\n    \"\"\"\n    int_part = 0\n    decimal_part = number % 1\n    half = 1 / 2\n\n    if decimal_part < half:\n        int_part = number % 1\n    elif decimal_part > half:\n        int_part = number + half\n        return number\n\n\ndef is_divisible_by(number: int, factor: int) -> bool:\n    \"\"\" Return True if and only if the number is evenly divisible by factor.\n    >>> is_divisible_by(10, 5)\n    True\n    >>> is_divisible_"}
{"task_id": "HumanEval/2", "completion": "    int_part, dec_part = math.modf(number)\n    return dec_part\n\n\n# Task 7: Use backslash character `\\` to write strings across the line in\n# multi-lines.\n\n#\"\"\" Calculate the area of a circle with a given radius. \"\"\"\n#def area_of_circle(radius: float) -> float:\n#    \"\"\" Return the area of a circle with a given radius. \"\"\"\n#    return math.pi * radius * \\\n#           radius\n#\n\n\"\"\" Calculate the area of a circle with a given radius. \"\"\"\ndef area_of_circle(radius: float) -> float:\n    \"\"\" Return the area of a circle with a given radius. \"\"\"\n    area = math.pi * radius * radius\n    return area\n\n\n# Task 8: Define a function `pythagorean_problem` that both takes two numbers\n# and returns them in a tuple. They represent a side `a` and `b` of a right-\n# angled triangle. Calculate the hypotenuse `c`.\n\ndef pythagorean_problem(a: int, b: int)"}
{"task_id": "HumanEval/2", "completion": "    int_part = int(number)\n    return number - int_part\n\n\n@static_vars(last_rounded=None)\ndef round_number(\n    number: float,\n    round_factor: float = DEFAULT_ROUND_FACTOR,\n    offset: float = DEFAULT_ROUND_OFFSET,\n) -> float:\n    \"\"\" Given a positive floating point number, round it to the closest multiple\n    of round_factor.\n\n    For example, round_factor of 0.5 will round values to the closest multiple\n    of 0.5.\n\n    The round_factor should be set so that the closest multiple of it to 1\n    is also a factor of round_factor. For example, 0.5, 0.25, 0.125 would be\n    valid options, but 0.15 would not. If the round_factor is not valid, a\n    ValueError in raised.\n\n    Optionally, an offset may be given. Values are rounded to the closest\n    multiple of the round_factor to this offset. The default is zero.\n    \"\"\"\n    # Check round_factor is valid\n    if round_"}
{"task_id": "HumanEval/2", "completion": "    number = np.nan_to_num(number)\n    int_part, dec_part = np.modf(number)\n    return dec_part"}
